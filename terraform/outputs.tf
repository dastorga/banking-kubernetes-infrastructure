# Terraform Outputs - Banking EKS Infrastructure

# VPC Information
output "vpc_id" {
  description = "ID of the Banking VPC"
  value       = aws_vpc.banking_vpc.id
}

output "vpc_cidr_block" {
  description = "CIDR block of the Banking VPC"
  value       = aws_vpc.banking_vpc.cidr_block
}

output "internet_gateway_id" {
  description = "ID of the Internet Gateway"
  value       = aws_internet_gateway.banking_igw.id
}

# Subnet Information
output "public_subnet_ids" {
  description = "IDs of the public subnets"
  value       = aws_subnet.public_subnets[*].id
}

output "private_subnet_ids" {
  description = "IDs of the private subnets"
  value       = aws_subnet.private_subnets[*].id
}

output "availability_zones" {
  description = "Availability zones used"
  value       = data.aws_availability_zones.available.names
}

# EKS Cluster Information
output "cluster_id" {
  description = "EKS cluster ID"
  value       = try(aws_eks_cluster.banking_cluster.id, null)
}

output "cluster_arn" {
  description = "EKS cluster ARN"
  value       = try(aws_eks_cluster.banking_cluster.arn, null)
}

output "cluster_endpoint" {
  description = "Endpoint for EKS control plane"
  value       = try(aws_eks_cluster.banking_cluster.endpoint, null)
  sensitive   = true
}

output "cluster_version" {
  description = "EKS cluster version"
  value       = try(aws_eks_cluster.banking_cluster.version, null)
}

output "cluster_platform_version" {
  description = "Platform version for the EKS cluster"
  value       = try(aws_eks_cluster.banking_cluster.platform_version, null)
}

output "cluster_status" {
  description = "Status of the EKS cluster"
  value       = try(aws_eks_cluster.banking_cluster.status, null)
}

# EKS Node Group Information
output "node_group_arn" {
  description = "EKS node group ARN"
  value       = try(aws_eks_node_group.banking_nodes.arn, null)
}

output "node_group_status" {
  description = "Status of the EKS node group"
  value       = try(aws_eks_node_group.banking_nodes.status, null)
}

# Security Group Information
output "cluster_security_group_id" {
  description = "Security group ID attached to the EKS cluster"
  value       = try(aws_eks_cluster.banking_cluster.vpc_config[0].cluster_security_group_id, null)
}

output "node_security_group_id" {
  description = "ID of the EKS node shared security group"
  value       = try(aws_security_group.eks_nodes.id, null)
}

# IAM Role Information
output "cluster_iam_role_name" {
  description = "IAM role name associated with EKS cluster"
  value       = try(aws_iam_role.eks_cluster.name, null)
}

output "cluster_iam_role_arn" {
  description = "IAM role ARN associated with EKS cluster"
  value       = try(aws_iam_role.eks_cluster.arn, null)
}

output "node_group_iam_role_name" {
  description = "IAM role name associated with EKS node group"
  value       = try(aws_iam_role.eks_nodes.name, null)
}

output "node_group_iam_role_arn" {
  description = "IAM role ARN associated with EKS node group"
  value       = try(aws_iam_role.eks_nodes.arn, null)
}

# Kubernetes Configuration
output "kubectl_config" {
  description = "kubectl config as generated by the module"
  value = templatefile("${path.module}/scripts/kubeconfig.tpl", {
    cluster_name     = local.cluster_name
    cluster_endpoint = try(aws_eks_cluster.banking_cluster.endpoint, "")
    cluster_ca       = try(aws_eks_cluster.banking_cluster.certificate_authority[0].data, "")
    aws_region       = var.aws_region
  })
  sensitive = true
}

# Connection Information for Applications
output "database_connection_info" {
  description = "Database connection information for applications"
  value = {
    host     = "postgres.banking-app.svc.cluster.local"
    port     = "5432"
    database = "banking_db"
    username = "banking_user"
  }
  sensitive = true
}

output "redis_connection_info" {
  description = "Redis connection information for applications"
  value = {
    host = "redis.banking-app.svc.cluster.local"
    port = "6379"
  }
}

# Application URLs (when using LoadBalancer services)
output "application_urls" {
  description = "URLs to access the banking application"
  value = {
    frontend_url = "http://${try(kubernetes_service.banking_frontend.status[0].load_balancer[0].ingress[0].hostname, "minikube-ip")}"
    backend_url  = "http://${try(kubernetes_service.banking_backend.status[0].load_balancer[0].ingress[0].hostname, "minikube-ip")}/api"
    api_docs_url = "http://${try(kubernetes_service.banking_backend.status[0].load_balancer[0].ingress[0].hostname, "minikube-ip")}/docs"
  }
}

# Monitoring Information
output "prometheus_url" {
  description = "Prometheus monitoring URL"
  value       = "http://${try(kubernetes_service.prometheus.status[0].load_balancer[0].ingress[0].hostname, "minikube-ip")}:9090"
}

output "grafana_url" {
  description = "Grafana dashboard URL"
  value       = "http://${try(kubernetes_service.grafana.status[0].load_balancer[0].ingress[0].hostname, "minikube-ip")}:3000"
}

# Namespace Information
output "kubernetes_namespace" {
  description = "Kubernetes namespace for banking application"
  value       = var.namespace
}

# Local Development Information
output "local_development_info" {
  description = "Information for local development with Minikube"
  value = {
    minikube_ip      = "Run 'minikube ip' to get the IP"
    frontend_port    = "Access via minikube service banking-frontend -n banking-app"
    backend_port     = "Access via minikube service banking-backend -n banking-app"
    dashboard_url    = "Run 'minikube dashboard' to access Kubernetes dashboard"
    kubectl_context  = "minikube"
    docker_env_cmd   = "eval $(minikube docker-env)"
  }
}

# Resource Tags
output "common_tags" {
  description = "Common tags applied to all resources"
  value       = local.common_tags
}

# Health Check Information
output "health_check_endpoints" {
  description = "Health check endpoints for monitoring"
  value = {
    backend_health  = "/api/health"
    frontend_health = "/nginx-health"
    postgres_ready  = "pg_isready -U banking_user -d banking_db"
    redis_ping      = "redis-cli ping"
  }
}